值类型：string、number、boolean、Null、undefined

引用类型：function、object、array

值类型存储于栈中，引用类型存储于堆中（值存储于堆中，地址存储于栈中）

引用类型的赋值操作是将引用类型堆上 的地址进行了复制。

## 函数参数引用传递和值传递的区别

    - 参数匹配是从左向右进行匹配；如果实参个数少于形参，后面的参数对应赋值是undefined;
      实参个数多余形参，可以用arguments访问。

函数参数如果是简单类型，会将一个值类型的数值副本传到函数内部；如果是引用类型，则会将引用类型的地址值复制传给函数的参数。

引用参数的传递,是传递引用对象的地址,函数内部对参数的修改会影响传递参数的引用对象；
值传递的是一个值类型的副本，函数内部对参数的修改不影响函数外部传递的参数变量；

每个函数内部都可以访问arguments，里面存放着我们传递给函数的参数;
arguments不是一个数组，它是一个类数组；其中有一个length属性，值就是传递的实参的个数；
函数的length属性可以得到形参的个数；

函数的参数对象化封装：如果一个函数的参数多余四个，那么开发人员很难记忆，我们就需要讲函数参数封装成一个对象。

## 浏览器事件循环机制

为啥js是单线程的？
js执行线程和UI线程互斥；

js中的代码都是依次序执行，不会同步执行多个任务；

异步任务：dom事件、ajax网络请求、setTimout、I/O、BOM的一些api;

事件执行机制：
    - js执行引擎的主线程从任务队列获取任务执行；
    - 如果是异步任务，运行到异步任务时，异步任务就退出主线程,主线程进行下一个任务的获取处理；
    - 如果异步任务完成，就插入到任务队列的末尾，等待主线程处理；

## 执行上下文

栈：先进后出；队列：先进先出。
EC:执行上下文 Execution Context
ECS: 执行环境栈, Execution Context Stack
VO: 变量对象,js的执行上下文中都有个对象用来存放执行上下文中可被访问但是不可被删除的函数标识符、形参、变量声明,它们会被挂在这个对象上,对象属性对应他们的名字，对象属性的值对应其值。但该对象在js环境中是不可访问的。
AO: 激活对象（活动对象）。变量对象用来存储上下文中的东西，那什么时候可以访问到它？
每进入一个执行上下文，其中的变量对象就被激活，也就是其中的函数标识符、形参、变量声明可以被访问到了
Scope chain：作用域链

![栈数据结构](https://user-gold-cdn.xitu.io/2020/4/29/171c68cfcc0afda0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 执行上下文的执行栈

- js是单线程的，所有代码都排队执行
- 一开始浏览器执行全局代码,首先创建全局上下文,压入执行栈的顶部；
- 每当进入一个函数，就会创建该函数的执行上下文，并将其压入执行栈的顶部;当前函数执行完成后,当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的执行引擎总是访问栈顶 的执行上下文；
- 全局上下文唯一，它在浏览器关闭时出栈。

代码执行之前，就会立即创建一个全局执行上下文 Global Excution Context

## 函数执行环境栈 的变化

![执行环境栈变化](https://user-gold-cdn.xitu.io/2020/1/9/16f8ad4ad9af1ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

值类型：string、number、boolean、Null、undefined

引用类型：function、object、array

值类型存储于栈中，引用类型存储于堆中（值存储于堆中，地址存储于栈中）

引用类型的赋值操作是将引用类型堆上 的地址进行了复制。

## 函数参数引用传递和值传递的区别

    - 参数匹配是从左向右进行匹配；如果实参个数少于形参，后面的参数对应赋值是undefined;
      实参个数多余形参，可以用arguments访问。

函数参数如果是简单类型，会将一个值类型的数值副本传到函数内部；如果是引用类型，则会将引用类型的地址值复制传给函数的参数。

引用参数的传递,是传递引用对象的地址,函数内部对参数的修改会影响传递参数的引用对象；
值传递的是一个值类型的副本，函数内部对参数的修改不影响函数外部传递的参数变量；

每个函数内部都可以访问arguments，里面存放着我们传递给函数的参数;
arguments不是一个数组，它是一个类数组；其中有一个length属性，值就是传递的实参的个数；
函数的length属性可以得到形参的个数；

函数的参数对象化封装：如果一个函数的参数多余四个，那么开发人员很难记忆，我们就需要讲函数参数封装成一个对象。

## 浏览器事件循环机制

为啥js是单线程的？
js执行线程和UI线程互斥；

js中的代码都是依次序执行，不会同步执行多个任务；

异步任务：dom事件、ajax网络请求、setTimout、I/O、BOM的一些api;

事件执行机制：
    - js执行引擎的主线程从任务队列获取任务执行；
    - 如果是异步任务，运行到异步任务时，异步任务就退出主线程,主线程进行下一个任务的获取处理；
    - 如果异步任务完成，就插入到任务队列的末尾，等待主线程处理；

## 执行上下文

栈：先进后出；队列：先进先出。
EC:执行上下文 Execution Context
ECS: 执行环境栈, Execution Context Stack
VO: 变量对象,js的执行上下文中都有个对象用来存放执行上下文中可被访问但是不可被删除的函数标识符、形参、变量声明,它们会被挂在这个对象上,对象属性对应他们的名字，对象属性的值对应其值。但该对象在js环境中是不可访问的。
AO: 激活对象（活动对象）。变量对象用来存储上下文中的东西，那什么时候可以访问到它？
每进入一个执行上下文，其中的变量对象就被激活，也就是其中的函数标识符、形参、变量声明可以被访问到了
Scope chain：作用域链

![栈数据结构](https://user-gold-cdn.xitu.io/2020/4/29/171c68cfcc0afda0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 执行上下文的执行栈

- js是单线程的，所有代码都排队执行
- 一开始浏览器执行全局代码,首先创建全局上下文,压入执行栈的顶部；
- 每当进入一个函数，就会创建该函数的执行上下文，并将其压入执行栈的顶部;当前函数执行完成后,当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的执行引擎总是访问栈顶 的执行上下文；
- 全局上下文唯一，它在浏览器关闭时出栈。

代码执行之前，就会立即创建一个全局执行上下文 Global Excution Context

## 函数执行环境栈 的变化

![执行环境栈变化](https://user-gold-cdn.xitu.io/2020/1/9/16f8ad4ad9af1ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 执行上下文的生命周期

> 总的生命周期：创建-》执行-》出栈等待销毁

创建阶段：                                   
- 生成变量对象                  
- 建立作用域链                               
- 确定this指向               

执行阶段:   
- 变量赋值
- 函数引用
- 函数引用

->执行完毕后出栈，等待被回收

创建阶段：
- 创建作用域链（scope chain）
- 创建变量对象（VO）:首先初始化函数的参数arguments，初始化函数声明，初始化变量(undefined)，函数的优先级要高于变量;如果变量和函数同名，变量会被忽略。

    - 创建arguments 对象, 检查上下文，初始化会参数名称和值，以及创建引用的复制；
    - 扫描上下文的函数声明（而非函数表达式）：

        - 每发现一个函数，就在变量对象上创建对应的属性（该函数名称），其具有指向该函数在内存中的引用。
        - 若函数名称已经存在，则引用指针将被重写
    - 扫描上下文的变量声明：
    
        - 每发现一个变量声明，就在变量对象上创建对应的属性（该变量名称）,并且初始化变量为undefined。
        - 若变量的名字在变量对象中已经存在，讲不会进行任何操作并继续扫描。
    - 确定上下文中this的指向。

执行阶段：
    执行变量赋值，代码执行

回收阶段：
    执行上下文出栈，并等待虚拟机回收执行上下文

