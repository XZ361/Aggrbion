值类型：string、number、boolean、Null、undefined

引用类型：function、object、array

值类型存储于栈中，引用类型存储于堆中（值存储于堆中，地址存储于栈中）

引用类型的赋值操作是将引用类型堆上 的地址进行了复制。

## 函数参数引用传递和值传递的区别

    - 参数匹配是从左向右进行匹配；如果实参个数少于形参，后面的参数对应赋值是undefined;
      实参个数多余形参，可以用arguments访问。

函数参数如果是简单类型，会将一个值类型的数值副本传到函数内部；如果是引用类型，则会将引用类型的地址值复制传给函数的参数。

引用参数的传递,是传递引用对象的地址,函数内部对参数的修改会影响传递参数的引用对象；
值传递的是一个值类型的副本，函数内部对参数的修改不影响函数外部传递的参数变量；

每个函数内部都可以访问arguments，里面存放着我们传递给函数的参数;
arguments不是一个数组，它是一个类数组；其中有一个length属性，值就是传递的实参的个数；
函数的length属性可以得到形参的个数；

函数的参数对象化封装：如果一个函数的参数多余四个，那么开发人员很难记忆，我们就需要讲函数参数封装成一个对象。

## 浏览器事件循环机制

为啥js是单线程的？
js执行线程和UI线程互斥；

js中的代码都是依次序执行，不会同步执行多个任务；

异步任务：dom事件、ajax网络请求、setTimout、I/O、BOM的一些api;

事件执行机制：
    - js执行引擎的主线程从任务队列获取任务执行；
    - 如果是异步任务，运行到异步任务时，异步任务就退出主线程,主线程进行下一个任务的获取处理；
    - 如果异步任务完成，就插入到任务队列的末尾，等待主线程处理；

## 执行上下文

栈：先进后出；队列：先进先出。
EC:执行上下文 Execution Context
ECS: 执行环境栈, Execution Context Stack
VO: 变量对象,js的执行上下文中都有个对象用来存放执行上下文中可被访问但是不可被删除的函数标识符、形参、变量声明,它们会被挂在这个对象上,对象属性对应他们的名字，对象属性的值对应其值。但该对象在js环境中是不可访问的。
AO: 激活对象（活动对象）。变量对象用来存储上下文中的东西，那什么时候可以访问到它？
每进入一个执行上下文，其中的变量对象就被激活，也就是其中的函数标识符、形参、变量声明可以被访问到了
Scope chain：作用域链

![栈数据结构](https://user-gold-cdn.xitu.io/2020/4/29/171c68cfcc0afda0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## 执行上下文的执行栈

- js是单线程的，所有代码都排队执行
- 一开始浏览器执行全局代码,首先创建全局上下文,压入执行栈的顶部；
- 每当进入一个函数，就会创建该函数的执行上下文，并将其压入执行栈的顶部;当前函数执行完成后,当前函数的执行上下文出栈，并等待垃圾回收。
- 浏览器的执行引擎总是访问栈顶 的执行上下文；
- 全局上下文唯一，它在浏览器关闭时出栈。

代码执行之前，就会立即创建一个全局执行上下文 Global Excution Context

## 函数执行环境栈 的变化

![执行环境栈变化](https://user-gold-cdn.xitu.io/2020/1/9/16f8ad4ad9af1ca3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)