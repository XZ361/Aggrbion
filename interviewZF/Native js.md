* 原生js

** 1. Es6的新特性：

let:声明变量 <br>
const:声明常量，即不能修改的量

var、let、const、的区别<br>
- 1. let和const声明变量不存在变量提升，如果要使用这个变量，我们需要在变量定义之后在使用；
- 2. let和const不能重复声明变量，重复声明会报错。
- 3. 用let和const在全局声明变量不会给window增加属性。
- 4. let和const出现在代码块中，会把代码块（字面量声明对象除外）变成块级作用域，并切出现暂时性死区。

class(创建类)

import、export（基于ES6的模块规范创建导入导出模块（文件、组件）；

new Set（数组去重）

Symbol(独一无二的值)    
`var a = Symbol('qqq');`

...arr(展开运算符、剩余运算符)<br>
${}模板字符串
 
解构赋值：
`let {a} = obj; let [b] =arr;`

for of循环：<br>
()=>{} 箭头函数<br>

箭头函数和普通函数的区别：<br>
- 1. 箭头函数是匿名函数，不能作为构造函数，不能使用new。
- 2. 箭头函数没有原型属性。
- 3. this指向不同，箭头函数的this是定义时所在的对象，普通函数看前面有没有. ,点前面是谁，this就是谁，没有点就是window
- 4. 不能使用arguments对象，该对象在函数体内不存在。

数组新增方法：flat、find、findIndex

对象新增方法：Object.assign()、Object.values()、Object.keys()、Object.create()...

** 2. Js数据类型

基本数据类型：number、boolean、string、null(空对象)、undefined（未定义的值）、Symbol（）（产生一个唯一的值，跟谁都不重复）、bigInt(大数类型)

null 和undefined的区别？<br>
- 1. null表示一个『无』的对象，转化为数值时为0.
- 2. undefined表示一个『无』的原始值，转为数值时为NaN.
- 3. 当声明的变量还未被初始化时，变量默认值为undefined。
- 4. null表示尚未存在的变量，常用来表示函数企图返回一个不存在的对象。
- 5. undefined 表示缺少值，就是此处应该有一个值，但是还没有定义。

典型用法是：<br>
- 1. 变量被声明了，但还没被赋值时，就等于undefined;
- 2. 调用函数时，应该提供的参数没有提供，该参数就等于undefined；
- 3. 对象没有赋值的属性，改属性就等于undefined;
- 4. 函数没有返回值时，默认返回undefined；

null表示『没有对象』，即此处不该有值。<br>
典型用法是：<br>
- 1. 作为函数的参数，表示该函数的参数不是对象。
- 2. 作为对象原型链的终点；

引用数据类型：对象

对象存储过程：<br>
- 1. 开辟一个空间地址；
- 2. 把键值对存储到这个空间地址的堆内存中；
- 3. 把这个对象指针赋值给变量名；
```
let obj = {
    a: 1,
    fn: (function(val){
        //赋给fn的是自执行函数的执行结果，也就是一个undefined；
        //盖子执行函数只会执行一次
        console.log(val);
    })(obj.a)
};
let obj2 = obj; //两者代表了同一个地址
//获取属性的值 obj.fn 或则obj['fn']
//新增属性：obj.c = 100或则obj['c'] = 100
//真删除：delete obj.a(在严格模式下不支持该方法)；假删除：obj.a = null;
```
基本数据类型和引用数据类型的区别：<br>
基本数据类型是操作值，引用数据类型操作的是堆内存空间地址；
```
检验有效数字的方法：isNaN
常用的数据类型检测方式：typeof constructor instanceof Object.prototype.toString.call()
```
比较运算符：<br>
== 相对运算符：会进行默认的类型转化；若转化后的值相等，则结果为true；<br>
=== 绝对比较： 值相同，类型相同；

引用数据类型之间的比较，就看是不是同一个地址；

逻辑运算符：<br>
|| 前边成立给前边，前边不成立给后边；
&& 

** 3. 定义函数的方法

- 1. function声明
```
//ES5
function getSum(){}
function(){} //匿名函数
//ES6
()=>{}
```
- 2. 函数表达式
```
//ES5
var getSum = function(){};
//ES6
let getSum =()=>{}
```
- 3. 构造函数
`const getSum =new Function('a','b','return a + b');`

** 4. JS作用域的理解
```
js中的作用域分为两种：全局作用域和函数作用域。
函数作用域中定义的变量，只能在函数中调用，外界无法访问。
没有块级作用域导致了if或for这样的逻辑语句中定义的变量可以呗外界访问
因此ES6中新增了let和const命令来进行块级作用域的声明。
//循环绑定的问题
for(var i=0;i<3;i++){
    setTimeout(
        ()=>console.log(i),1
    )
}
for(lei i=0;i< 3;i++){
    setTimout(
        ()=>console.log(i)
    );
}
作用域链：变量的查找机智
上级作用域 函数在哪里定义的，那么该函数执行形成的作用的上级作用域就是谁；
//了解了上级作用域，就比较容易查找变量对应的值

```
** 5.闭包的理解
```
简单来说，闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，
使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外部污染，
使其一直存在于内村中，在业务开发中还是少使用闭包的好，因为闭包太消耗内存，不到万不得已尽量不要使用闭包。
```
** 6. 数组

>   数组去重
    - 双for循环去重
    - 利用对象的属性名不能重复去重
    - 利用Es6的Set不能重复去重

** 7.原型及原型链

> 原型
    - 函数都带有一个prototype属性，该属性指向构造函数的原型对象，这个对象包含所有实例共享的属性和方法。
    - 原型对象都有一个constructor属性，改属性指向所关联的构造函数
    - 每个对象都有一个__proto__属性，改属性指向构造函数的原型prototype

> 原型链
    - 当访问实例对象的某个属性时，会先在该对象本身的属性上查找，如果没有找到，则会通过__proto__属性去原型上查找,如果还没有找到则会在构造函数的原型的__proto__查找,这样一层层向上查找就会形成一个作用域链，称为原型链。





















