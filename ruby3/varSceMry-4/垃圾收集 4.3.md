## 4.3 垃圾收集

😁JavaScript自动具有垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。原理很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔周期性的执行者这一操作。

局部变量的生命周期：局部变量只在函数执行的过程中存在。在该过程中，会为局部变量在栈或堆内存上分配响应而空间，已存储他们的值。然后在函数中使用这些变量，知道函数结束。垃圾收集器对于不在有用的变量打上标记，以备将来收回其占用的内存。

### 4.3.1 标记清楚

js中最常用的垃圾收集方式是标记清除。当变量进入环境时，就标记为进入环境；当变量离开环境时，就将其标记为离开环境。

垃圾收集器在运行时会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。再次之后，再被加上标记的变量将会被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除的工作，销毁那些带标记的值并回收他们所占用的内存空间。

### 4.3.2 引用计数

引用计数的含义是追踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数为1 ；如果同一个值又被赋给另一个变量，则该值的引用次数加1.相反，如果包含对该值引用的变量又取得了另外的一个值，则该值的引用次数减一。当该值的引用次数为0时，说明无法在访问这个值，就可以讲起所占用的内存空间回收。这样，当垃圾收集器下次再运行时，就会释放那些引用次数为0的值所占用的内存。

***缺点***：引用计数存在循环引用的问题：循环引用指对象A包含一个指向对象B的指针，对象B中也包含一个指向A的引用。

```
function problem(){
    var objA = new Object();
    var objB = new Object();
    objA.someOtherObject = objectB;
    objB.anthorObject = objectA;
}

```

### 4.3.4 管理内存

内存限制不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。

因此确保占用最少的内存可以让也页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一但数据不在有用，最好将其值设置为null来释放其引用---这种方式称为解除引用。

解除引用的真正作用是让值脱离执行环境，以便在垃圾收集下次运行时将其回收。
