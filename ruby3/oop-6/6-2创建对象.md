** 6.2 创建对象
虽然Object构造函数和对象字面量都可以用来创建单个对象，但是有明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决该问题，工厂模式的一种变体开始流行。

*** 6.2.1 工厂模式
抽象了创建对象的具体过程。
```
function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    }
    return o;
}
var person1 = new createPerson("jack", 29, "Software Engineer");
var person2 = new createPerson("Greg", 22, "Doctor");
```
工厂模式虽然解决了创建多个相似对象的问题，但却无法解决对象识别的问题（即怎样知道一个对象的类型)<br>
随着js的发展，构造函数模式出现了。

*** 6.2.2 构造函数模式
创建自定义的构造函数，从而定义自定义对象类型的属性和方法。<br>
构造函数模式重写上述例子：
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName =function(){
        alert(this.name);
    }
}
var person1 = new Person("jack", 29, "Software Engineer");
var person2 = new Person("Greg", 22, "Doctor");
```
我们发现通过构造函数创建对象存在几处不同：<br>
- 没有显式的创建对象
- 直接讲属性和方法赋给了this对象
- 没有return语句
- 函数名使用大写P。（按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头）

要创建person的新实例，必须使用new操作符。这种方式调用构造函数会经历4个阶段：
- 1 创建一个新对象；
- 2 讲构造函数的作用域赋给新对象(因此this就指向了新对象);
- 3 执行构造函数中的代码（为这个新对象添加属性）；
- 4 返回新对象；

person1和person2都有一个constructor属性，改属性指向Person；<br>
person1.constructor == Person;
true
person2.constructor == Person;
true

我们创建的实例即是Object的实例，同时也是Person的实例。可以用instanceof检测。检测对象类型，用instanceof靠谱些。

创建自定义的构造函数表示可以将他的实例标定为一中特定的类型，这正是构造函数模式的优点；<br>
- 1. 讲构造函数当做函数
任何函数，只要通过new操作符来调用，那它就可以作为构造函数；任何函数，如果不通过new操作符来调用，那它跟普通函数没什么区别；
```
//当做构造函数使用
var person = new Person("Jack",28,"Software Engineer");
person.sayName();   //Jack

//作为普通函数使用
Person("Greg",27,"Doctor"); //添加到window
window.sayName();   //Greg

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25  ,"Nurse");
o.sayName();    //Kristen
```
当在全局作用域中调用一个函数时，this对象总是指向Global(在浏览器中就是window对象)。<br>
也可以使用call（）（或则apply）在某个特殊对象的作用域中调用Person函数，改特殊对象自动拥有Person函数的所有属性和方法。
- 2. 构造函数的问题
主要问题是每个方法都要在每个实例上重新创建一遍。

通过把函数定义转移到构造函数外边来解决；
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name);
}
var person1 = new Person("jack", 29, "Software Engineer");
var person2 = new Person("Greg", 22, "Doctor");
```
我们把sayName（）函数的定义转移到了构造函数外部。而在构造函数内部，我们将sayName属性设置为等于全局的sayName函数，
这样一来，由于sayName包含的是一个指向函数的指针，因此Person1和Person2对象就共享了在全局作用域中定义的同一个sayName函数。
这么做确实解决了两个函数重复做同一件事的问题。但是存在新问题：全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实，而且让人无法接受的是，如果对象需要定义很多方法，那么就需要定义很多的全局函数，于是这个自定义的引用类型就没有封装性可说了。

好在上述问题可以通过使用原型模式解决。

*** 6.2.3 原型模式<br>
我们创建的每个函数都有一个prototype（原型属性），改属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面意思理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。

使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。
```
function Person(){}
Person.prototype.name = "Nicholas";
Person.prototype.age = 22;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
person1.sayName()   //"Nicholas"
var person2 = new Person();
person2.sayName()   //"Nicholas"
console.log(person1.sayName === person2.sayName); //true
```
要理解原型模式的工作原理，需要先理解ECMAScript中原型对象的性质。

- 1. 理解原型对象
> 无论何时，只要创建一个新函数，就会根据一组特定的规则，为该函数创建一个prototype属性，改属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个constructor属性，改属性包含一个指向prototype属性所在函数的指针。例如Person.prototype.constructor 指向Person。通过该构造函数，我们可以继续为原型对象添加其他属性和方法。

创建了自定义的构造函数后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。5版本中将该指针称为[[prototype]].虽然在脚本中没有标准的方式访问[[prototype]],但在主流浏览器中的每个对象上都支持一个属性_proto_;在其他实现中，改属性对脚本完全不可见。重点是该链接存在于实例与构造函数的原型对象之间，而非实例和构造函数之间。

下图6-1展示了各个对象之间的关系
![6-1](https://upload-images.jianshu.io/upload_images/5788579-cc9472b313000753.jpg)

上图展示了Person构造函数、Person原型属性以及Person现有的两个实例之间的关系。Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor之外，还包括后来添加的其他属性。

Person的每个实例person1和person2都包含一个内部属性，改属性仅仅指向了Person.prototype;他们与构造函数没有直接的关系。虽然两个实例都不包含任何属性和方法，但我们却可以调用sayName（）方法。这是通过查找对象属性过程实现的。

注意：我们在所有实现中都无法访问到[[Prototype]],但可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。
从本质上讲，如果[[prototype]]指向调用isPrototypeOf（）方法的对象（Person.prototype）,那么该方法返回true。
```
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
```
因为两个实例内部都有一个指向Person.prototype的指针，因此返回了true。

ES5新增了一个方法，Object.getPrototypeOf(),该方法返回[[Prototype]]的值。
```
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Object.getPrototypeOf(person1).name); //"Nicholas"
```
第一行确定该方法返回的对象就是这个对象的原型，第二行取得了原型对象中name属性的值。
使用Object.getPrototypeOf可以方便的获取一个对象的原型，在利用原型实现继承的情况下非常重要。

>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回改属性的值；如果未找到，则继续搜索指针指向的原型对象，在原型对象中查找给定名字的属性。如果找到了，就返回改属性的值。
这正是多个对象实例共享原型所保存的属性和方法的基本原理。

我们可以通过对象实例访问保存在原型中的值，但是不能通过对象实例重写原型中的值。

假如我们在实例中添加了一个属性，改属性和实例原型中的一个属性同名，我们在实例中创建改属性，改属性会屏蔽原型中的那个属性。
```
function Person(){}
Person.prototype.name = "Nicholas";
Person.prototype.age = 22;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
    alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
person1.name = "Greg";
alert(perosn1.name);    //"Greg"   --来自实例
alert(perosn2.name);    //"Nicholas"   --来自原型
```
>


