** 6.2 创建对象
虽然Object构造函数和对象字面量都可以用来创建单个对象，但是有明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为了解决该问题，工厂模式的一种变体开始流行。

*** 6.2.1 工厂模式
抽象了创建对象的具体过程。
```
function createPerson(name,age,job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    }
    return o;
}
var person1 = new createPerson("jack", 29, "Software Engineer");
var person2 = new createPerson("Greg", 22, "Doctor");
```
工厂模式虽然解决了创建多个相似对象的问题，但却无法解决对象识别的问题（即怎样知道一个对象的类型)<br>
随着js的发展，构造函数模式出现了。

*** 6.2.2 构造函数模式
创建自定义的构造函数，从而定义自定义对象类型的属性和方法。<br>
构造函数模式重写上述例子：
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName =function(){
        alert(this.name);
    }
}
var person1 = new Person("jack", 29, "Software Engineer");
var person2 = new Person("Greg", 22, "Doctor");
```
我们发现通过构造函数创建对象存在几处不同：<br>
- 没有显式的创建对象
- 直接讲属性和方法赋给了this对象
- 没有return语句
- 函数名使用大写P。（按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头）

要创建person的新实例，必须使用new操作符。这种方式调用构造函数会经历4个阶段：
- 1 创建一个新对象；
- 2 讲构造函数的作用域赋给新对象(因此this就指向了新对象);
- 3 执行构造函数中的代码（为这个新对象添加属性）；
- 4 返回新对象；

person1和person2都有一个constructor属性，改属性指向Person；<br>
person1.constructor == Person;
true
person2.constructor == Person;
true

我们创建的实例即是Object的实例，同时也是Person的实例。可以用instanceof检测。检测对象类型，用instanceof靠谱些。

创建自定义的构造函数表示可以将他的实例标定为一中特定的类型，这正是构造函数模式的优点；<br>
- 1. 讲构造函数当做函数
任何函数，只要通过new操作符来调用，那它就可以作为构造函数；任何函数，如果不通过new操作符来调用，那它跟普通函数没什么区别；
```
//当做构造函数使用
var person = new Person("Jack",28,"Software Engineer");
person.sayName();   //Jack

//作为普通函数使用
Person("Greg",27,"Doctor"); //添加到window
window.sayName();   //Greg

//在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25  ,"Nurse");
o.sayName();    //Kristen
```
当在全局作用域中调用一个函数时，this对象总是指向Global(在浏览器中就是window对象)。<br>
也可以使用call（）（或则apply）在某个特殊对象的作用域中调用Person函数，改特殊对象自动拥有Person函数的所有属性和方法。
- 2. 构造函数的问题
主要问题是每个方法都要在每个实例上重新创建一遍。

通过把函数定义转移到构造函数外边来解决；
```
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}
function sayName(){
    alert(this.name);
}
var person1 = new Person("jack", 29, "Software Engineer");
var person2 = new Person("Greg", 22, "Doctor");
```
我们把sayName（）函数的定义转移到了构造函数外部。而在构造函数内部，我们将sayName属性设置为等于全局的sayName函数，
这样一来，由于sayName包含的是一个指向函数的指针，因此Person1和Person2对象就共享了在全局作用域中定义的同一个sayName函数。
这么做确实解决了两个函数重复做同一件事的问题。但是存在新问题：全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实，而且让人无法接受的是，如果对象需要定义很多方法，那么就需要定义很多的全局函数，于是这个自定义的引用类型就没有封装性可说了。

好在上述问题可以通过使用原型模式解决。

*** 6.2.3 原型模式



