** 6.3 继承
>继承是OO语言中的一个重要概念。许多OO语言都支持两种继承方法：
- 接口继承：只继承方法签名
- 实现继承：继承实际的方法
***由于函数没有签名，在ECMAScript无法实现接口继承。只支持实现继承，实现继承主要是依靠原型链实现 ***

*** 6.3.1 
>ECMAScript中描述了原型链，并将原型链作为实现继承的主要方法。基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

构造函数、原型和实例的关系：
>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型的对象的内部指针。<br>
假如我们让原型对象等于另一个类型的实例，显然，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含一个指向另一个构造函数的指针。假如另一个原型中又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例和原型的链条，这就是原型链的基本概念。

实现原型链的基本模式：
```
function SuperType(){
    this.property = true;
}
SuperType.prototype.getSuperValue = function(){
    return this.property;
}
function SubType(){
    this.subproperty = false;
}
//继承了SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function(){
    return this.subproperty;
}
var instance = new SubType();
alert(instance.getSuperValue());    //true
```
>SubType 继承了SuperType,继承通过创建SuperType 的实例，并将该实例赋给SubType.prototype实现的。本质是重写了原型对象，代之以一个新类型的实例。原来存在于SuperType中的属性和方法，现在也存在于SubType.prototype中了。

当前实例以及构造函数和原型之间的关系如下：
!(6-4)[https://book.miaoyunze.com/res/pic/6_5_1.jpg]

我们没有使用SubType默认提供的原型，而是换了一个新原型；这个新原型就是SuperType的实例。于是新原型不仅具有作为一个SuperType实例所拥有的全部属性和方法。而且其内部还存在一个指针，指向了SuperType的原型。最终结果变成了这样：instance指向SubType的原型，SubType的原型指向SuperType的原型。getSuperValue方法仍然还在SuperType.prototype中，但是property位于SubType.prototype中。因为propert是一个实例属性，而getSuperValue是一个原型方法。SubType.prototype因为是SuperType的实例，所以property位于该实例中。

通过实现原型链，扩展了前面的原型搜索机制。当以读取模式访问一个实例属性时，首先会在该实例中搜索改属性。如果未找到，则会继续搜索实例的原型。在通过过原型链实现继承的情况下，搜索过程得以沿着原型链继续向上。
- 1. 别忘记默认的原型

